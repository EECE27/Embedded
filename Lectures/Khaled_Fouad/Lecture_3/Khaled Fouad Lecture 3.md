## **Intro to Program Architecture
- Inputs:
  - Periodic
  - Random
  - High Rate
  - Low Rate

```c
// Typical Program Architecture

int main(void)
{
	// Hardware Intializations
	while(1)
	{
		1. Get Inputs
		2. Process Inputs
		3. Take Decisions according to processed Inputs
	}
}
```
## **How to Deal with inputs
## Polling:
- **Polling** : while look that periodically check for inputs till input is received and read. Like serial port loops on the ready flag on a status port waiting for data till it received successfully.
	- Latency can not be predicated and no guarantee that data will be received (Implement a time out for safety).
```c
char serial_input(void)
{
	while((inport(SERIAL_STATUS_PORT) & RC_READY == 0))
	{
		//Idle do nothing
	}
	return data;
}
```
#### Polling Problems:
- Timing and syncing is software dependant and changes by changing code or hardware
- Bad for large data blocks **Storage and Network**
- Difficult for debugging
- High energy consumption **(Always On)**
- Hard to keep multiple devices in sync -> Problem in my ESP code :)

## **Interrupt Based I/O:
**Internal Interrupt**: generated by on chip peripheral (Timers, serial comms, adc, etc...)
**External Interrupt**: generated by peripheral connected to the MCU via external pins
**Exceptions**: thrown by processor (reset, division by zero, overflow, watchdog)
**Software Interrupts**: useful to steer the control flow of the app, bad if not done right (It is more evident in Operating Systems)
	- Software interrupts are useful in moving execution of a program from userspace to system space by a software interrupt triggered by an evident in a program ran.
**NMI (Non-Maskable Interrupts)**:  Interrupts that can't be turned on or off

Interrupt controller in programmable (PIC: Programmable Input Controller) 
 - Controls Priority of different interrupts, masks interrupts of lesser priority
 - External Interrupts are usually Edge Based (Rising or Falling edges).

 **IVT (Interrupt Vector Table)
 - Does not control priorities
 - Merely contains the address of the interrupt service routine called.

### Interrupt Service Routines (ISR):
- The function called and executed when an interrupt is triggered.
##### Execution of ISR:
- Save current processor state (Context Switching)
- Load interrupt handling function (Callback, Handling function etc..)
- After execution restore the processor state again. (Complete context switching).

- Switch stack pointer to the interrupt stack and save the main stack pointer
- Mask lower priority interrupts
- Perform a minimum amount of work in ISR -> (Advice)
- Return

> **DO NOT EXECUTE LARGE DATA IN ISR
	FATAL MISTAKE



ISR Usually moves data to memory in the program or adjust a flag to signal that data is received
##### **Main Advantage over Polling:
Timing can be adjusted as its not waiting for an input periodically like with polling. could go to sleep mode while it waits for input.

#### Drawbacks of interrupts:
- They are not neglible, they cost time
- Too Much interrupts especially nested interrupts could cause switching overhead (Too much switching occuring).
- Longer ISRs could cause starvation for other computation tasks.

**Clear Your Interrupts:
- Leaving them set will have the processor ignore them.

**Use Interrupt Levels
**Control Resource variables (Global Variables and stuff)
- Multiple processes can access data at the same time (How to Solve this?)
	- There are ways this can be solved that will be explained later one, mostly depending on RTOS (Real Time Operating System) using semaphores to mark specific resources.

## **Program Architecture:

>To RTOS or not to RTOS
		**This is the question!
	-Khaled Fouad in this early carreer :D


### Bare Meal Embedded Arch:
- Software runs directly on target HW
- Does not use an OS
>Advantages:
>- Simple Embedded systems
>- very Constrained enviroments
>- Low level firmware (Comms TX in SoC)

> Disadvantages:
> - Re-invent the wheel.
> - specific to hardware (Not Portable)
> - not very power efficient (Super loop)
> - Timing

#### Bare-Metal Program

```c
// Typical Program Architecture

int main(void)
{
	// Hardware Intializations
	init();
	while(1)
	{
		task1();
		task2();
		task3();
		.
		.
		.
		.
		taskN();
		sleep(SomePeriod);
	}
}